"""
Traffic Flow Analysis - Verification Script
--------------------------------------------
This script verifies the **lane assignment and vehicle counting** output
generated by `traffic_flow.py`.

Key Functions:
1. Loads the `vehicle_counts.csv` generated from the detection pipeline.
2. Summarizes:
   - Total rows in CSV
   - Unique vehicle IDs
   - Counts per lane
   - Vehicles assigned to multiple lanes (possible tracking errors)
3. Extracts **sample frames** from the video for manual inspection:
   - Saves first-appearance frames for a few vehicles per lane.
   - Draws lane separators and vehicle labels.
4. Saves a `first_appear_summary.csv` for further review.

Why This Is Important:
- Manual verification is a key QA step for any computer vision pipeline.
- Allows us to visually confirm the accuracy of detection, tracking, and lane assignment.

Author: [Your Name]
"""
import os
import cv2
import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt

# CONFIG
CSV_PATH = "vehicle_counts.csv"
VIDEO_PATH = "traffic_video.mp4"
SAMPLES_PER_LANE = 4               # how many first-appearance samples per lane to save
OUTPUT_DIR = "verify_samples"      # where sample images will be saved

# Create output folder
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Load CSV
df = pd.read_csv(CSV_PATH)

# Basic checks
rows = len(df)
unique_vehicles = df['VehicleID'].nunique()
counts_per_lane = df['LaneNumber'].value_counts().sort_index().to_dict()

# First appearance per vehicle (frame, lane, timestamp)
first_appear = df.groupby('VehicleID', as_index=False).agg({'Frame':'min','LaneNumber':'first','Timestamp':'min'})

# Vehicles assigned to multiple lanes?
lane_changes = df.groupby('VehicleID')['LaneNumber'].nunique()
multi_lane_ids = lane_changes[lane_changes > 1].index.tolist()

print("=== QUICK SUMMARY ===")
print(f"Total rows in CSV: {rows}")
print(f"Unique Vehicle IDs: {unique_vehicles}")
print(f"Counts per lane (rows): {counts_per_lane}")
print(f"Vehicles assigned to multiple lanes: {len(multi_lane_ids)}")
if len(multi_lane_ids) > 0:
    print("Example IDs with multiple lanes:", multi_lane_ids[:10])
print("======================\n")

# Open video
cap = cv2.VideoCapture(VIDEO_PATH)
if not cap.isOpened():
    raise SystemExit(f"ERROR: Could not open video file {VIDEO_PATH}")

frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = cap.get(cv2.CAP_PROP_FPS) or 30.0

# Default lane split (change if you used custom lanes)
lane_width = frame_width // 3
lanes = [
    (0, lane_width),                # Lane 1
    (lane_width, 2 * lane_width),   # Lane 2
    (2 * lane_width, frame_width)   # Lane 3
]

# Select sample vehicle IDs per lane (first-appearance)
samples = []
for lane_idx in [1, 2, 3]:
    ids_in_lane = first_appear[first_appear['LaneNumber'] == lane_idx]['VehicleID'].tolist()
    samples.extend(ids_in_lane[:SAMPLES_PER_LANE])

# Limit duplicates and total size
samples = list(dict.fromkeys(samples))  # preserve order, unique
print(f"Saving {len(samples)} sample frames for manual inspection to '{OUTPUT_DIR}'\n")

# Extract and save frames
saved = 0
for vid in samples:
    row = first_appear[first_appear['VehicleID'] == vid].iloc[0]
    fnum = int(row['Frame'])
    lane_assigned = int(row['LaneNumber'])
    # Seek to the frame (OpenCV uses zero-based)
    cap.set(cv2.CAP_PROP_POS_FRAMES, max(0, fnum - 1))
    ret, frame = cap.read()
    if not ret:
        # try a few frames around the target
        ok = False
        for offset in [1,2,3,4,5]:
            cap.set(cv2.CAP_PROP_POS_FRAMES, max(0, fnum - offset))
            ret, frame = cap.read()
            if ret:
                ok = True
                break
        if not ok:
            print(f"Warning: couldn't read frame {fnum} for ID {vid}")
            continue

    # Draw vertical lane separators and labels
    display = frame.copy()
    for i,(xs, xe) in enumerate(lanes, start=1):
        cv2.line(display, (xe, 0), (xe, frame_height), (0, 0, 255), 3)
        cv2.putText(display, f"Lane {i}", (xs + 10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0,0,255), 2, cv2.LINE_AA)

    label = f"ID:{int(vid)}  AssignedLane:{lane_assigned}  Frame:{fnum}"
    cv2.putText(display, label, (10, frame_height - 20),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,0), 2, cv2.LINE_AA)

    out_path = os.path.join(OUTPUT_DIR, f"sample_ID{vid}_L{lane_assigned}_F{fnum}.png")
    cv2.imwrite(out_path, display)
    saved += 1

print(f"Saved {saved} sample images to {OUTPUT_DIR}")
cap.release()

# Create a small report CSV summarizing first appearances
first_appear_sorted = first_appear.sort_values('Frame').reset_index(drop=True)
report_path = os.path.join(OUTPUT_DIR, "first_appear_summary.csv")
first_appear_sorted.to_csv(report_path, index=False)
print(f"Saved summary CSV: {report_path}")
